import { NextResponse } from "next/server";
import { Client } from "@line/bot-sdk";
import { saveData, fetchData } from "@/app/services/supabase/query.js";
import { processAIRequest } from "@/app/ai/core/index.js";
import crypto from "crypto";

const config = {
  channelAccessToken: process.env.LINE_ADMIN_CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.LINE_ADMIN_CHANNEL_SECRET,
};

const client = new Client(config);

// Configuration for admin response behavior
const ADMIN_RESPONSE_CONFIG = {
  mode: process.env.LINE_ADMIN_RESPONSE_MODE || "auto", // "auto", "manual", "ai", "off"
  autoResponseDelay: parseInt(process.env.LINE_AUTO_RESPONSE_DELAY) || 0, // seconds
  enableSmartResponse: process.env.LINE_ENABLE_SMART_RESPONSE === "true",
  businessHours: {
    enabled: process.env.LINE_BUSINESS_HOURS_ENABLED === "true",
    start: process.env.LINE_BUSINESS_START || "09:00",
    end: process.env.LINE_BUSINESS_END || "18:00",
    timezone: process.env.LINE_BUSINESS_TIMEZONE || "Asia/Bangkok",
  },
};

export async function POST(request) {
  try {
    const body = await request.text();
    const signature = request.headers.get("x-line-signature");

    // Verify LINE signature
    if (!verifySignature(body, signature)) {
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }

    const events = JSON.parse(body).events;

    for (const event of events) {
      await handleLineEvent(event);
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("LINE webhook error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

async function handleLineEvent(event) {
  try {
    if (event.type !== "message" || event.message.type !== "text") {
      return;
    }

    const { source, message, timestamp } = event;
    const lineUserId = source.userId;
    const messageContent = message.text;

    // Get LINE user profile
    let lineUsername = null;
    try {
      const profile = await client.getProfile(lineUserId);
      lineUsername = profile.displayName;
    } catch (error) {
      console.log("Could not get LINE profile:", error);
    }

    // Generate conversation session ID (daily session)
    const today = new Date().toISOString().split("T")[0];
    const conversationSessionId = `${lineUserId}_${today}`;

    // Save user message to database
    await saveConversationMessage({
      line_user_id: lineUserId,
      line_username: lineUsername,
      message_role: "user",
      message_content: messageContent,
      message_type: message.type,
      conversation_session_id: conversationSessionId,
      metadata: {
        timestamp: new Date(timestamp).toISOString(),
        message_id: message.id,
        source_type: source.type,
      },
    });

    // Process admin response based on configuration
    const adminResponse = await processAdminResponse(
      messageContent,
      lineUserId,
      event
    );

    if (adminResponse && adminResponse.shouldSend) {
      // Add delay if configured
      if (ADMIN_RESPONSE_CONFIG.autoResponseDelay > 0) {
        await new Promise((resolve) =>
          setTimeout(resolve, ADMIN_RESPONSE_CONFIG.autoResponseDelay * 1000)
        );
      }

      // Save admin response to database
      await saveConversationMessage({
        line_user_id: lineUserId,
        line_username: lineUsername,
        message_role: "admin",
        message_content: adminResponse.text,
        message_type: "text",
        conversation_session_id: conversationSessionId,
        admin_id: adminResponse.adminId,
        admin_name: adminResponse.adminName,
        metadata: {
          response_timestamp: new Date().toISOString(),
          auto_generated: adminResponse.autoGenerated || false,
          response_mode: adminResponse.mode,
          confidence_score: adminResponse.confidenceScore,
        },
      });

      // Send response to LINE user
      await client.replyMessage(event.replyToken, {
        type: "text",
        text: adminResponse.text,
      });
    } else if (!adminResponse?.shouldSend) {
      console.log(
        `No response sent for user ${lineUserId}. Mode: ${ADMIN_RESPONSE_CONFIG.mode}`
      );
    }
  } catch (error) {
    console.error("Error handling LINE event:", error);
  }
}

async function saveConversationMessage(messageData) {
  try {
    const result = await saveData("line_admin_conversations", messageData);

    if (!result.success) {
      console.error("Failed to save conversation:", result.error);
      return false;
    }

    console.log("Conversation message saved:", result.data.id);
    return true;
  } catch (error) {
    console.error("Error saving conversation message:", error);
    return false;
  }
}

async function processAdminResponse(userMessage, lineUserId, event) {
  const mode = ADMIN_RESPONSE_CONFIG.mode;

  switch (mode) {
    case "off":
      return { shouldSend: false };

    case "manual":
      return await handleManualMode(userMessage, lineUserId);

    case "ai":
      return await handleAIMode(userMessage, lineUserId);

    case "auto":
    default:
      return await handleAutoMode(userMessage, lineUserId);
  }
}

async function handleAutoMode(userMessage, lineUserId) {
  // Check business hours if enabled
  if (ADMIN_RESPONSE_CONFIG.businessHours.enabled) {
    const isBusinessHours = checkBusinessHours();
    if (!isBusinessHours) {
      return {
        text: "ขอบคุณสำหรับข้อความของคุณ ขณะนี้อยู่นอกเวลาทำการ เราจะติดต่อกลับในเวลาทำการ (9:00-18:00 น.)",
        adminId: null,
        adminName: "Auto Response System (After Hours)",
        autoGenerated: true,
        shouldSend: true,
        mode: "auto_after_hours",
      };
    }
  }

  // Smart response based on message content
  if (ADMIN_RESPONSE_CONFIG.enableSmartResponse) {
    return await generateSmartResponse(userMessage, lineUserId);
  }

  // Default auto response
  return {
    text: "ขอบคุณสำหรับข้อความของคุณ เราจะตอบกลับในไม่ช้า",
    adminId: null,
    adminName: "Auto Response System",
    autoGenerated: true,
    shouldSend: true,
    mode: "auto_default",
  };
}

async function handleManualMode(userMessage, lineUserId) {
  // In manual mode, only save the message but don't auto-respond
  // Admins will respond manually through admin interface

  // Optional: Send a notification to admins about new message
  await notifyAdmins(userMessage, lineUserId);

  return { shouldSend: false, mode: "manual" };
}

async function handleAIMode(userMessage, lineUserId) {
  try {
    // Get conversation history for context
    const conversationHistory = await getRecentConversationHistory(lineUserId);

    // Generate AI response
    const aiResponse = await generateAIResponse(
      userMessage,
      conversationHistory,
      lineUserId
    );

    return {
      text: aiResponse.text,
      adminId: null,
      adminName: "AI Assistant",
      autoGenerated: true,
      shouldSend: true,
      mode: "ai",
      confidenceScore: aiResponse.confidence,
    };
  } catch (error) {
    console.error("AI response generation failed:", error);
    // Fallback to auto mode
    return await handleAutoMode(userMessage, lineUserId);
  }
}

async function generateSmartResponse(userMessage, lineUserId) {
  try {
    // Analyze message intent
    const intent = analyzeMessageIntent(userMessage);

    let responseText = "";
    let adminName = "Smart Auto Response";

    switch (intent.type) {
      case "greeting":
        responseText =
          "สวัสดีครับ/ค่ะ ยินดีต้อนรับสู่ CKC Car Services มีอะไรให้เราช่วยเหลือไหมครับ/ค่ะ";
        break;

      case "car_inquiry":
        responseText =
          "ขอบคุณที่สนใจรถของเราครับ/ค่ะ เรามีรถหลากหลายรุ่นให้เลือก ท่านสนใจรถรุ่นไหนเป็นพิเศษไหมครับ/ค่ะ";
        break;

      case "price_inquiry":
        responseText =
          "เรื่องราคารถ เราจะแจ้งราคาพิเศษให้ท่านครับ/ค่ะ ขอเบอร์โทรติดต่อหน่อยได้ไหมครับ/ค่ะ";
        break;

      case "contact_request":
        responseText =
          "แอดมินจะติดต่อกลับไปให้ท่านในไม่ช้าครับ/ค่ะ หรือท่านสะดวกให้เราโทรหาเมื่อไหร่ครับ/ค่ะ";
        break;

      case "complaint":
        responseText =
          "ขอโทษด้วยครับ/ค่ะ เราจะส่งเรื่องให้ทีมที่เกี่ยวข้องดูแลท่านโดยเร็วที่สุดครับ/ค่ะ";
        adminName = "Customer Service";
        break;

      case "phone_number":
        responseText =
          "ขอบคุณสำหรับเบอร์โทรครับ/ค่ะ เราจะให้แอดมินโทรหาท่านในไม่ช้าครับ/ค่ะ";
        break;

      default:
        responseText = "ขอบคุณสำหรับข้อความของคุณ เราจะตอบกลับในไม่ช้า";
    }

    return {
      text: responseText,
      adminId: null,
      adminName: adminName,
      autoGenerated: true,
      shouldSend: true,
      mode: "smart_auto",
      intent: intent.type,
      confidenceScore: intent.confidence,
    };
  } catch (error) {
    console.error("Smart response generation failed:", error);
    return await handleAutoMode(userMessage, lineUserId);
  }
}

function analyzeMessageIntent(message) {
  const lowerMessage = message.toLowerCase();

  // Greeting patterns
  if (/สวัสดี|หวัดดี|ดีครับ|ดีค่ะ|hello|hi/.test(lowerMessage)) {
    return { type: "greeting", confidence: 0.9 };
  }

  // Car inquiry patterns
  if (/รถ|คาร์|car|ราคา|price|สนใจ|ดู|เช่า|ซื้อ/.test(lowerMessage)) {
    return { type: "car_inquiry", confidence: 0.8 };
  }

  // Price inquiry patterns
  if (/ราคา|เท่าไร|เท่าไหร่|price|cost|ค่า/.test(lowerMessage)) {
    return { type: "price_inquiry", confidence: 0.85 };
  }

  // Contact request patterns
  if (/โทร|ติดต่อ|contact|call|คุย/.test(lowerMessage)) {
    return { type: "contact_request", confidence: 0.8 };
  }

  // Phone number patterns
  if (/\d{3}[-.\s]?\d{3}[-.\s]?\d{4}|0\d{8,9}/.test(message)) {
    return { type: "phone_number", confidence: 0.95 };
  }

  // Complaint patterns
  if (/ร้องเรียน|แย่|ไม่ดี|ปัญหา|เสีย|complaint/.test(lowerMessage)) {
    return { type: "complaint", confidence: 0.7 };
  }

  return { type: "general", confidence: 0.5 };
}

async function generateAIResponse(
  userMessage,
  conversationHistory,
  lineUserId
) {
  try {
    const systemPrompt = `You are a helpful customer service assistant for CKC Car Services, a car dealership in Thailand. 
    Respond in Thai language, be polite and professional. 
    Help customers with car inquiries, pricing, and general questions.
    Keep responses concise and friendly.`;

    const conversationContext = conversationHistory
      .slice(-10) // Last 10 messages for context
      .map((msg) => `${msg.message_role}: ${msg.message_content}`)
      .join("\n");

    const userPrompt = `
    Previous conversation:
    ${conversationContext}
    
    Customer message: ${userMessage}
    
    Please provide a helpful response:`;

    const aiResponse = await processAIRequest(
      [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      {},
      "web",
      { temperature: 0.7, maxTokens: 200 }
    );

    return {
      text: aiResponse.content.trim(),
      confidence: 0.8,
    };
  } catch (error) {
    console.error("AI response generation error:", error);
    throw error;
  }
}

async function getRecentConversationHistory(lineUserId) {
  try {
    const result = await fetchData("line_admin_conversations", {
      filters: { line_user_id: lineUserId },
      sort: [{ column: "created_at", ascending: false }],
      limit: 20,
    });

    return result.success ? result.data.reverse() : [];
  } catch (error) {
    console.error("Error fetching conversation history:", error);
    return [];
  }
}

async function notifyAdmins(userMessage, lineUserId) {
  // Implement admin notification logic here
  // Could be email, push notification, or internal messaging system
  console.log(`New message from ${lineUserId}: ${userMessage}`);
}

function checkBusinessHours() {
  const now = new Date();
  const options = {
    timeZone: ADMIN_RESPONSE_CONFIG.businessHours.timezone,
    hour12: false,
  };

  const currentTime = now.toLocaleTimeString("en-US", options).slice(0, 5);
  const startTime = ADMIN_RESPONSE_CONFIG.businessHours.start;
  const endTime = ADMIN_RESPONSE_CONFIG.businessHours.end;

  return currentTime >= startTime && currentTime <= endTime;
}

function verifySignature(body, signature) {
  const hash = crypto
    .createHmac("sha256", process.env.LINE_ADMIN_CHANNEL_SECRET)
    .update(body)
    .digest("base64");

  return hash === signature;
}

// GET endpoint for retrieving conversation data
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get("action");
    const lineUserId = searchParams.get("userId");
    const date = searchParams.get("date");
    const adminId = searchParams.get("adminId");

    switch (action) {
      case "conversations":
        return await getConversations(lineUserId, date);

      case "daily_summary":
        return await getDailySummary(date);

      case "admin_performance":
        return await getAdminPerformance(adminId, date);

      case "config":
        return NextResponse.json({
          success: true,
          config: ADMIN_RESPONSE_CONFIG,
        });

      default:
        return NextResponse.json({ error: "Invalid action" }, { status: 400 });
    }
  } catch (error) {
    console.error("GET request error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

async function getConversations(lineUserId, date) {
  const filters = {};

  if (lineUserId) {
    filters.line_user_id = lineUserId;
  }

  if (date) {
    // Get conversations for specific date
    const startDate = new Date(date);
    const endDate = new Date(date);
    endDate.setDate(endDate.getDate() + 1);

    const result = await fetchData("line_admin_conversations", {
      filters,
      gte: { created_at: startDate.toISOString() },
      lt: { created_at: endDate.toISOString() },
      sort: [{ column: "created_at", ascending: true }],
    });

    return NextResponse.json(result);
  }

  const result = await fetchData("line_admin_conversations", {
    filters,
    sort: [{ column: "created_at", ascending: false }],
    limit: 100,
  });

  return NextResponse.json(result);
}

async function getDailySummary(date) {
  const targetDate = date || new Date().toISOString().split("T")[0];
  const startDate = new Date(targetDate);
  const endDate = new Date(targetDate);
  endDate.setDate(endDate.getDate() + 1);

  const result = await fetchData("line_admin_conversations", {
    gte: { created_at: startDate.toISOString() },
    lt: { created_at: endDate.toISOString() },
    sort: [{ column: "created_at", ascending: true }],
  });

  if (result.success) {
    const summary = {
      date: targetDate,
      total_messages: result.data.length,
      unique_users: [...new Set(result.data.map((msg) => msg.line_user_id))]
        .length,
      admin_responses: result.data.filter((msg) => msg.message_role === "admin")
        .length,
      user_messages: result.data.filter((msg) => msg.message_role === "user")
        .length,
      conversations: result.data,
    };

    return NextResponse.json({ success: true, data: summary });
  }

  return NextResponse.json(result);
}

async function getAdminPerformance(adminId, date) {
  // Now get from customers table instead of admin_performance_reports
  const filters = {};

  if (date) {
    const startDate = new Date(date);
    const endDate = new Date(date);
    endDate.setDate(endDate.getDate() + 1);

    // Get customers with admin performance data for the date
    const result = await fetchData("customers", {
      filters: {
        last_conversation_date: {
          gte: startDate.toISOString(),
          lt: endDate.toISOString(),
        },
      },
      sort: [{ column: "last_conversation_date", ascending: false }],
    });

    if (result.success) {
      // Extract admin performance from customer data
      const adminPerformanceData = result.data.map((customer) => ({
        customer_id: customer.id,
        customer_name: customer.customer_name,
        line_user_id: customer.line_user_id,
        admin_performance: customer.admin_performance_summary,
        last_conversation: customer.last_conversation_date,
      }));

      return NextResponse.json({
        success: true,
        date: date,
        data: adminPerformanceData,
      });
    }

    return NextResponse.json(result);
  }

  // Get recent customers with admin performance data
  const result = await fetchData("customers", {
    filters,
    sort: [{ column: "last_conversation_date", ascending: false }],
    limit: 50,
  });

  return NextResponse.json(result);
}
