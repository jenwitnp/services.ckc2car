import { NextResponse } from "next/server";
import { Client, validateSignature } from "@line/bot-sdk";
import { saveData, fetchData } from "@/app/services/supabase/query.js";
import { lineConfigService } from "@/app/services/supabase/lineConfig.js";
// ✅ Use your existing LINE adapter
import { processLineRequest } from "@/app/ai/adapters/line.js";
import { ContextService } from "@/app/ai/services/context/ContextService.js";
import { LineUtilsService } from "@/app/services/line/LineUtilsService.js";
import { LineResponseBuilder } from "@/app/services/line/LineResponseBuilder.js";

const config = {
  channelAccessToken: process.env.LINE_ADMIN_CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.LINE_ADMIN_CHANNEL_SECRET,
};

const client = new Client(config);
const contextService = new ContextService();

// ✅ Use LINE SDK's built-in signature verification
function verifySignature(body, signature) {
  try {
    return validateSignature(
      body,
      process.env.LINE_ADMIN_CHANNEL_SECRET,
      signature
    );
  } catch (error) {
    console.error("LINE signature verification error:", error);
    return false;
  }
}

export async function POST(request) {
  try {
    const body = await request.text();
    const signature = request.headers.get("x-line-signature");

    if (!verifySignature(body, signature)) {
      console.error("Invalid LINE signature for admin channel");
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }

    const events = JSON.parse(body).events;

    for (const event of events) {
      await handleLineEvent(event);
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("LINE webhook error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

async function handleLineEvent(event) {
  try {
    if (event.type !== "message" || event.message.type !== "text") {
      return;
    }

    const { source, message, timestamp } = event;
    const lineUserId = source.userId;
    const messageContent = message.text;

    console.log("Processing LINE admin message:", {
      userId: lineUserId,
      messageLength: messageContent?.length,
      timestamp: timestamp,
    });

    // ✅ Get LINE user profile
    let lineUsername = null;
    try {
      const profile = await client.getProfile(lineUserId);
      const formattedProfile = LineUtilsService.formatUserProfile(profile);
      lineUsername = formattedProfile.displayName;
    } catch (error) {
      console.log("Could not get LINE profile:", error);
    }

    // ✅ Generate session ID
    const conversationSessionId = LineUtilsService.generateSessionId(
      lineUserId,
      "admin"
    );

    // ✅ Format and save user message
    const userMessageData = LineUtilsService.formatMessageForDatabase(
      {
        lineUserId: lineUserId,
        lineUsername: lineUsername,
        role: "user",
        content: messageContent,
        type: message.type,
        sessionId: conversationSessionId,
        metadata: {
          timestamp: new Date(timestamp).toISOString(),
          message_id: message.id,
          source_type: source.type,
          channel_type: "admin",
          event_type: event.type,
        },
      },
      "customer"
    );

    await saveConversationMessage(userMessageData);

    // Get admin response configuration
    const ADMIN_RESPONSE_CONFIG = await getAdminResponseConfig();
    console.log("auto res config :", ADMIN_RESPONSE_CONFIG);

    // ✅ Process admin response
    const adminResponse = await processAdminResponse(
      messageContent,
      lineUserId,
      event,
      ADMIN_RESPONSE_CONFIG
    );

    if (adminResponse && adminResponse.shouldSend) {
      // Add configured delay
      if (ADMIN_RESPONSE_CONFIG.autoResponseDelay > 0) {
        await new Promise((resolve) =>
          setTimeout(resolve, ADMIN_RESPONSE_CONFIG.autoResponseDelay * 1000)
        );
      }

      // ✅ Format and save admin response - use text for database
      const adminMessageData = LineUtilsService.formatMessageForDatabase(
        {
          lineUserId: lineUserId,
          lineUsername: lineUsername,
          role: "admin",
          content:
            adminResponse.text ||
            adminResponse.response?.text ||
            adminResponse.response?.altText ||
            "AI Response",
          type: "text",
          sessionId: conversationSessionId,
          adminId: adminResponse.adminId,
          adminName: adminResponse.adminName,
          metadata: {
            response_timestamp: new Date().toISOString(),
            auto_generated: adminResponse.autoGenerated || false,
            response_mode: adminResponse.mode,
            confidence_score: adminResponse.confidenceScore,
            channel_type: "admin",
            response_type: adminResponse.response?.type, // Track if it was text/flex
          },
        },
        "admin"
      );

      await saveConversationMessage(adminMessageData);

      // ✅ Send LINE response - use the full response object
      console.log("Sending LINE response:", {
        type: adminResponse.response?.type,
        hasText: !!adminResponse.response?.text,
        hasContents: !!adminResponse.response?.contents,
      });

      await client.replyMessage(event.replyToken, adminResponse.response);
    }
  } catch (error) {
    console.error("Error handling LINE event:", error);

    // Emergency fallback response
    try {
      const fallbackResponse = LineResponseBuilder.createTextResponse(
        "ขออภัยครับ เกิดข้อผิดพลาดในระบบ กรุณาลองใหม่อีกครั้งครับ"
      );
      await client.replyMessage(event.replyToken, fallbackResponse);
    } catch (fallbackError) {
      console.error("Even fallback response failed:", fallbackError);
    }
  }
}

// ✅ Save function with better error handling
async function saveConversationMessage(messageData) {
  try {
    console.log("Saving message to line_admin_conversations:", {
      line_user_id: messageData.line_user_id,
      message_role: messageData.message_role,
      message_type: messageData.message_type,
      conversation_session_id: messageData.conversation_session_id,
      has_admin_id: !!messageData.admin_id,
      has_admin_name: !!messageData.admin_name,
      metadata_keys: Object.keys(messageData.metadata || {}),
    });

    const result = await saveData("line_admin_conversations", messageData);

    console.log("Message saved successfully:", result);
    return result;
  } catch (error) {
    console.error("Error saving conversation message:", error);
    console.error("Message data:", messageData);
  }
}

async function getAdminResponseConfig() {
  try {
    const config = await lineConfigService.getConfig();
    return {
      mode: config.mode || "manual",
      autoResponseDelay: config.auto_response_delay || 0,
      enableSmartResponse: config.enable_smart_response || false,
      businessHours: {
        enabled: config.business_hours_enabled || false,
        start: config.business_hours_start || "09:00",
        end: config.business_hours_end || "18:00",
        timezone: config.business_hours_timezone || "Asia/Bangkok",
      },
    };
  } catch (error) {
    console.error("Error getting admin response config:", error);
    return {
      mode: "manual",
      autoResponseDelay: 0,
      enableSmartResponse: false,
      businessHours: {
        enabled: false,
        start: "09:00",
        end: "18:00",
        timezone: "Asia/Bangkok",
      },
    };
  }
}

async function processAdminResponse(messageContent, lineUserId, event, config) {
  try {
    if (config.mode === "manual") {
      return { shouldSend: false };
    }

    // Check business hours
    if (config.businessHours.enabled) {
      const isWithinHours = LineUtilsService.checkBusinessHours(
        config.businessHours
      );
      if (!isWithinHours) {
        return {
          shouldSend: true,
          response: LineResponseBuilder.createTextResponse(
            `ขออภัยค่ะ ขณะนี้อยู่นอกเวลาทำการ เวลาทำการคือ ${config.businessHours.start} - ${config.businessHours.end} น. เราจะตอบกลับในเวลาทำการนะคะ`
          ),
          autoGenerated: true,
          mode: "business_hours",
          adminId: null,
          adminName: "Business Hours Bot",
        };
      }
    }

    // ✅ FIXED: Use your existing LINE adapter for full AI functionality
    if (config.enableSmartResponse && config.mode === "ai") {
      try {
        // ✅ Get context using your existing ContextService
        const baseContext = await contextService.getUserContext(lineUserId);
        const context = {
          ...baseContext,
          userId: lineUserId,
          platform: "line",
          channel: "admin", // ✅ Identify as admin channel
          isAdminChannel: true,
        };

        console.log("[Admin LINE] Processing with LINE adapter:", {
          userId: lineUserId,
          messageLength: messageContent.length,
          hasCarModels: !!context.carModels,
        });

        // ✅ Use your existing LINE adapter - it handles everything!
        const aiResponse = await processLineRequest(messageContent, context);

        console.log("[Admin LINE] AI Response:", {
          type: aiResponse?.type,
          hasText: !!aiResponse?.text,
          hasContents: !!aiResponse?.contents,
          isFlexMessage: aiResponse?.type === "flex",
        });

        // ✅ Your LINE adapter already returns properly formatted responses
        if (aiResponse) {
          // Extract text for logging/metadata
          let responseText = null;
          if (aiResponse.type === "text") {
            responseText = aiResponse.text;
          } else if (aiResponse.type === "flex") {
            responseText = aiResponse.altText || "Flex message response";
          }

          return {
            shouldSend: true,
            response: aiResponse, // ✅ Use the full LINE response object
            text: responseText, // For database logging
            autoGenerated: true,
            mode: "ai_smart",
            confidenceScore: 0.9,
            adminId: null,
            adminName: "AI Assistant",
          };
        } else {
          console.warn(
            "AI response is null/undefined, falling back to default"
          );
        }
      } catch (aiError) {
        console.error(
          "AI processing failed, falling back to default:",
          aiError
        );
      }
    }

    // Default auto response (fallback)
    const defaultText =
      "สวัสดีครับ ขอบคุณที่ติดต่อเรา ทีมงานจะติดต่อกลับไปในเร็วๆ นี้นะครับ";
    return {
      shouldSend: true,
      response: LineResponseBuilder.createTextResponse(defaultText),
      text: defaultText,
      autoGenerated: true,
      mode: "default_auto",
      adminId: null,
      adminName: "Auto Response",
    };
  } catch (error) {
    console.error("Error processing admin response:", error);
    return { shouldSend: false };
  }
}

// ✅ Add function to get conversation history for AI context
async function getRecentConversationHistory(lineUserId, limit = 10) {
  try {
    const result = await fetchData("line_admin_conversations", {
      filters: {
        line_user_id: lineUserId,
      },
      sort: ["created_at", "desc"],
      limit: limit,
    });

    if (!result.success || !result.data) {
      return [];
    }

    // ✅ Format for AI - convert to expected message format
    return result.data.reverse().map((msg) => ({
      role: msg.message_role === "admin" ? "assistant" : "user",
      content: msg.message_content,
      timestamp: msg.created_at,
    }));
  } catch (error) {
    console.error("Error getting conversation history:", error);
    return [];
  }
}

// ✅ GET endpoints
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get("action");

    switch (action) {
      case "config":
        const config = await lineConfigService.getConfig();
        return NextResponse.json({
          success: true,
          config: {
            mode: config.mode,
            autoResponseDelay: config.auto_response_delay,
            enableSmartResponse: config.enable_smart_response,
            businessHours: {
              enabled: config.business_hours_enabled,
              start: config.business_hours_start,
              end: config.business_hours_end,
              timezone: config.business_hours_timezone,
            },
          },
        });

      case "daily_summary":
        const date =
          searchParams.get("date") || new Date().toISOString().split("T")[0];
        const stats = await getDailyStats(date);
        return NextResponse.json({
          success: true,
          data: stats,
        });

      case "conversations":
        const lineUserId = searchParams.get("userId");
        const conversationDate = searchParams.get("date");
        return await getConversations(lineUserId, conversationDate);

      case "stats":
        const statsData = await getConversationStats();
        return NextResponse.json({
          success: true,
          data: statsData,
        });

      default:
        return NextResponse.json({ error: "Invalid action" }, { status: 400 });
    }
  } catch (error) {
    console.error("GET request error:", error);
    return NextResponse.json(
      { error: "Internal server error", details: error.message },
      { status: 500 }
    );
  }
}

// ✅ FIXED: getConversations function
async function getConversations(lineUserId, date) {
  try {
    // ✅ Build options object for fetchData
    const options = {
      sort: ["created_at", "desc"],
      limit: 100,
    };

    // ✅ Add user filter if provided
    if (lineUserId) {
      options.filters = {
        line_user_id: lineUserId,
      };
    }

    // ✅ Add date filter if provided
    if (date) {
      const startDate = new Date(date);
      const endDate = new Date(date);
      endDate.setDate(endDate.getDate() + 1);

      options.gte = {
        created_at: startDate.toISOString(),
      };

      // ✅ Use 'lt' instead of 'lte' for the end date to exclude the next day
      options.lte = {
        created_at: endDate.toISOString(),
      };
    }

    // ✅ FIXED: Use fetchData correctly
    const result = await fetchData("line_admin_conversations", options);

    if (!result.success) {
      throw new Error(result.message || "Failed to fetch conversations");
    }

    return NextResponse.json({
      success: true,
      data: result.data || [],
      meta: {
        total: result.data?.length || 0,
        count: result.count || 0,
        filtered_by: {
          line_user_id: lineUserId || "all",
          date: date || "all",
        },
      },
    });
  } catch (error) {
    console.error("Error fetching conversations:", error);
    return NextResponse.json(
      {
        error: "Failed to fetch conversations",
        details: error.message,
      },
      { status: 500 }
    );
  }
}

async function getDailyStats(date) {
  try {
    const startDate = new Date(date);
    const endDate = new Date(date);
    endDate.setDate(endDate.getDate() + 1);

    // ✅ FIXED: Use the fetchData options parameter correctly
    const result = await fetchData("line_admin_conversations", {
      gte: {
        created_at: startDate.toISOString(),
      },
      lte: {
        created_at: endDate.toISOString(),
      },
    });

    // ✅ Handle the result structure from fetchData
    if (!result.success) {
      throw new Error(result.message || "Failed to fetch conversations");
    }

    const conversations = result.data || [];

    const stats = {
      date: date,
      total_messages: conversations.length,
      user_messages: conversations.filter((c) => c.message_role === "user")
        .length,
      admin_responses: conversations.filter((c) => c.message_role === "admin")
        .length,
      unique_users: [...new Set(conversations.map((c) => c.line_user_id))]
        .length,
      auto_responses: conversations.filter(
        (c) => c.message_role === "admin" && c.metadata?.auto_generated === true
      ).length,
      response_modes: {},
    };

    // Count response modes
    conversations
      .filter((c) => c.message_role === "admin")
      .forEach((c) => {
        const mode = c.metadata?.response_mode || "unknown";
        stats.response_modes[mode] = (stats.response_modes[mode] || 0) + 1;
      });

    return stats;
  } catch (error) {
    console.error("Error getting daily stats:", error);
    return {
      date: date,
      error: error.message,
      total_messages: 0,
      user_messages: 0,
      admin_responses: 0,
      unique_users: 0,
      auto_responses: 0,
      response_modes: {},
    };
  }
}

async function getConversationStats() {
  try {
    // ✅ FIXED: Use fetchData correctly
    const result = await fetchData("line_admin_conversations", {
      sort: ["created_at", "desc"],
      limit: 1000,
    });

    if (!result.success) {
      throw new Error(result.message || "Failed to fetch conversations");
    }

    const conversations = result.data || [];

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    const todayMessages = conversations.filter(
      (c) => new Date(c.created_at) >= today
    );

    const yesterdayMessages = conversations.filter((c) => {
      const msgDate = new Date(c.created_at);
      return msgDate >= yesterday && msgDate < today;
    });

    return {
      total_conversations: conversations.length,
      today: {
        total: todayMessages.length,
        users: todayMessages.filter((c) => c.message_role === "user").length,
        admins: todayMessages.filter((c) => c.message_role === "admin").length,
        unique_users: [...new Set(todayMessages.map((c) => c.line_user_id))]
          .length,
      },
      yesterday: {
        total: yesterdayMessages.length,
        users: yesterdayMessages.filter((c) => c.message_role === "user")
          .length,
        admins: yesterdayMessages.filter((c) => c.message_role === "admin")
          .length,
        unique_users: [...new Set(yesterdayMessages.map((c) => c.line_user_id))]
          .length,
      },
      unique_users_total: [...new Set(conversations.map((c) => c.line_user_id))]
        .length,
      last_activity: conversations[0]?.created_at || null,
    };
  } catch (error) {
    console.error("Error getting conversation stats:", error);
    return {
      error: error.message,
      total_conversations: 0,
      today: { total: 0, users: 0, admins: 0, unique_users: 0 },
      yesterday: { total: 0, users: 0, admins: 0, unique_users: 0 },
      unique_users_total: 0,
      last_activity: null,
    };
  }
}
